---
layout:     post
title:      "GBDT"
subtitle:   "梯度提升决策树"
date:       2017-05-01
author:     "MrTriste"
header-img: "img/post-bg-js-module.jpg"
tags:
    - GBDT
    - 人工智能
    - 机器学习
---


## GBDT

GBDT(Gradient Boosting Decision Tree) 又叫 MART（Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力（generalization)较强的算法。

GBDT中的每课决策树都是回归树。

那么为什么我们要提出GBDT呢？

与上述的回归问题的提升树比较，当损失函数是平方损失和指数损失函数时，每一步的优化是很简单的。但对一般损失函数而言，往往每一步的优化都不是那么容易。针对这个问题，我们提出了梯度提升(Gradient boosting)算法。这是利用最速下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值作为回归问题提升树算法的中的残差的近似值。

说白了，那我们求导类比，如果我们求二次函数、指数函数的导，会很简单，因为有公式，那么对于一个很复杂的函数求导怎么求呢？只能根据定义，$$\mathop{f'}(x)=\frac{\delta y}{\delta x}$$来求。



## 具体的过程 

(1).根据自定义的损失函数初始化，找到损失最小的

$$f_0(x) = \mathop{\arg \min}_ a\sum_{i=1}^{N}L(y_i,c)$$

(2).迭代过程，对于$$m=1,2,...,M$$

a.计算负梯度(对应于回归问题提升树的残差)

$$r_{mi}=-[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)},i=1,2,3,...,N $$

b.拟合负梯度$$r_{mi}$$学习一个回归树，得到每棵树的叶节点区域$$R_{mj},j=1,2,...,J$$

c.对$$j=1,2,...,J$$，计算

$$c_{mj}=\mathop{\arg \min}_c \sum_{x_i \in R_{mj}}L(y_i,f_{m-1}(x_i)+c)$$

d.更新$$f_m(x) = f_{m-1}+\sum _{j=1}^Jc_{mj}I(X \in R_{mj})$$

(3).最终的分类器：

$$f_M(x) = \sum_{m=1}^M\sum_{j=1}^Jc_{mj}I(X \in R_{mj})$$



**PS**:(2)的b、c我看不懂啊

b:拟合一个回归树，是按照自己定义的损失函数拟合吗？比如对于提升树的二分类回归问题，类比过来就是根据平方损失函数找到一个切分点和$$c_1,c_2$$。

c:如何得到$$c_{mj}$$啊，根据自己的损失函数的特性？





## 回归问题的提升树&GBDT

总的来说两者相同之处在于，都是迭代回归树，都是累加每颗树结果作为最终结果（Multiple Additive Regression Tree)，每棵树都在学习前N-1棵树尚存的不足，从总体流程和输入输出上两者是没有区别的；两者的不同主要在于每步迭代时，是否使用Gradient作为求解方法。前者不用Gradient而是用残差----残差是全局最优值，Gradient是局部最优方向*步长，即前者每一步都在试图让结果变成最好，后者则每步试图让结果更好一点。

**两者优缺点**。看起来前者更科学一点--有绝对最优方向不学，为什么舍近求远去估计一个局部最优方向呢？原因在于灵活性。前者最大问题是，由于它依赖残差，cost function一般固定为反映残差的均方差，因此很难处理纯回归问题之外的问题。而后者求解方法为梯度下降，只要可求导的cost function都可以使用，所以用于排序的LambdaMART就是用的后者。